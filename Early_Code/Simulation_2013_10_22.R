################################################################################
# Program: Simulation_2013_10_22
# Project: Boucher Senior Thesis
# Description: Conduct a preliminary simulation study for CLS ordering vs SIS
#
# Author: Kimberly Boucher
# Date: 22 Oct 2013
#
# Notes:

################################################################################

library(mvtnorm)
library(Matrix)

# Set initial values, define functions for generating data in linear model

set.seed(20131022)
n <- 60 # number of y_i's/observations
m <- 500 # number of replicate data sets
p <- 1000 # number of predictors

default_c <- 0.6
# b1 <- c(0.9, 10)
# b2 <- c(0.3, p/2)
# b3 <- c(0.1, 3)
#blocks <- c(b1, b2, b3)
blocks <- c(default_c, p)

cov.generate <- function(blocks, p) {
  c <- matrix(data=c(blocks), ncol=2, byrow=T) # correlation of predictors in and size of each block
  if(sum(c[,2]) < p) {
    b_default <-c(default_c, p - sum(c[,2]))
    blocks <- c(blocks, b_default)
    c <- matrix(data=blocks, ncol=2, byrow=T)
  }
  cov <- matrix(bdiag(apply(c, 1, function(x) {matrix(data=rep(x[1],x[2]**2), nrow=x[2]) + diag(rep(1-x[1], x[2]))})), nrow=p)
}
cov<-cov.generate(blocks, p)

corr <- matrix(data=NA, nrow=p, ncol=m)
e<-rep(NA, n)

for(j in 1:m) {
  e<-c(data=rnorm(n, mean=0, sd=1)) # needs different variance when response depends on predictors
#  X<-matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
#  X<-abs(matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)) 
  # useful for distance measure, since that is just abs of pearson corr coeff when all normal
  X<-rmvnorm(n, mean=rep(0,p), cov) 
# system.time(X<-rmvnorm(60, rep(1,1000), diag(1000))) 
  # highly correlated predictors, compound symmetric aka equicorrelated generated by multivariate normal
  beta<-rep(0,p)
  y<-e+X%*%beta # just noise
  corr[,j]<-cor(y,X)
}

maxes <- apply(abs(corr), 2, max)
plot(density(maxes))

meds <- apply(abs(corr), 2, median)
#plot(density(meds))






