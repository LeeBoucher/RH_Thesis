################################################################################
# Program: Simulation_setup
# Project: Boucher Senior Thesis
# Description: Conduct a preliminary simulation study for CLS ordering vs SIS
#
# Author: Kimberly Boucher
# Date: 
#
# Notes:

################################################################################

# library(mvtnorm)
library(Matrix)

# Set initial values, define functions for generating data in linear model

initialize_values <- function(n, m, p, t, s, seed) {
  default_n <- 60
  default_m <- 500
  default_p <- 1000
  default_s <- 1
  
  if(missing(t)) { t <- FALSE }
  if(t) {
    default_n <- 6
    default_m <- 50
    default_p <- 100
#     default_n <- 2
#     default_m <- 5
#     default_p <- 10
  }
  
  if(missing(n)) { n <- default_n }
  if(missing(m)) { m <- default_m }
  if(missing(p)) { p <- default_p }
  
  default_seed <- 20131105
  if(missing(seed)) { seed <- default_seed }
  set.seed(seed)
  
  n <<- n # number of y_i's/observations
  m <<- m # number of replicate data sets
  p <<- p # number of predictors
  
  corr.pearson <<- matrix(data=NA, nrow=p, ncol=m)
  corr.dist <<- matrix(data=NA, nrow=p, ncol=m)
  varcov <<- matrix(data=NA, nrow=p, ncol=p)
  
  y <<- rep(NA, n)
  e <<- rep(NA, n)
  beta1 <<- rep(NA, p)
  beta1hat <<- rep(NA, p)
  beta0 <<- rep(NA, n)
  beta0hat <<- rep(NA, n)
  X <<- matrix(NA, nrow=n, ncol=p)
}

generate_cases <- function() {
  cases <<- 1
#   b1 <- matrix(NA, nrow=p, ncol=cases)
#   b0 <- matrix(NA, nrow=n, ncol=cases)
# #   vc <- rep(NA, cases)
#   R.squared <- rep(NA,cases)
# 
#   
#   b1[,1] <- rep(0,p)
#   
#   b0[,1] <- rep(1,n)
#   
# #   vc[[1]] <- varcov.generate(p=p)
#   R.squared[[1]] <- 0.6
#   
#   Cases <<- list(b1, b0, R.squared)
# #   names(cases) <- ("b1", "b0", "vc", "R.squared")
}

get_case <- function(case) {
  beta0 <<- rep(0,n)
  beta1 <<- rep(0,p)
  varcov <<- varcov.generate(p=p)
  rs <<- 0.6
}

# generate_data <- function(varcov, rs) {
generate_data <- function() {
# #   beta1 <<- rep(0,p)
# #   beta0 <<- rep(0,n)
# #   e <<- c(data=rnorm(n, mean=0, sd=1))
# #   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
# #   y <<- e + X %*% beta1 + beta0
#   
#   e <<- c(data=rnorm(n, mean=0, sd=1)) # needs different variance when response depends on predictors
#   #  X<-matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
#   #  X<-abs(matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)) 
#   # useful for distance measure, since that is just abs of pearson corr coeff when all normal
#   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
#   # highly correlated predictors, compound symmetric aka equicorrelated generated by multivariate normal
# #   beta0 <<- rep(0,p)
#   y <<- e + X %*% beta1 + beta0 # just noise
  
  X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
  
  if(t(beta1) %*% beta1 == 0) {
    e.sd <<- 1
  } else {
    ss <- ((1-rs^2)*t(beta1) %*% varcov %*% beta1)/(rs^2)
    v <- var(X %*% beta1)
    e.sd <<- v/(v + ss)
  }
  e <<- c(data=rnorm(n, mean=0, sd=e.sd))
  
  y <<- e + X %*% beta1 + beta0
  
}

varcov.generate <- function(p, blocks, default_c) {
  if(missing(default_c)) { default_c <- 0.6 }
  if(missing(blocks)) { blocks = c(default_c, p) }
  c <- matrix(data=c(blocks), ncol=2, byrow=T) # correlation of predictors in and size of each block
  if(sum(c[,2]) < p) {
    b_default <-c(default_c, p - sum(c[,2]))
    blocks <- c(blocks, b_default)
    c <- matrix(data=blocks, ncol=2, byrow=T)
  }
  varcov <- matrix(bdiag(apply(c, 1, function(x) {matrix(data=rep(x[1],x[2]**2), nrow=x[2]) + diag(rep(1-x[1], x[2]))})), nrow=p)
}

maxes_meds_plots <- function(corr) {
  maxes <<- apply(abs(corr), 2, max)
  plot(density(maxes))
  
  meds <<- apply(abs(corr), 2, median)
  # plot(density(meds))
}


