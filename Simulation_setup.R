################################################################################
# Program: Simulation_setup
# Project: Boucher Senior Thesis
# Description: Conduct a preliminary simulation study for CLS ordering vs SIS
#
# Author: Kimberly Boucher
# Date: 
#
# Notes:

################################################################################

library(mvtnorm)
library(Matrix)

# Set initial values, define functions for generating data in linear model

initialize_values <- function(n, m, p, t, s, seed) {
  default_n <- 60
  default_m <- 500
  default_p <- 1000
  default_s <- 1
  
  if(missing(t)) { t <- FALSE }
  if(t) {
    default_n <- 6
    default_m <- 50
    default_p <- 100
  }
  
  if(missing(n)) { n <- default_n }
  if(missing(m)) { m <- default_m }
  if(missing(p)) { p <- default_p }
  
  default_seed <- 20131105
  if(missing(seed)) { seed <- default_seed }
  set.seed(seed)
  
  n <<- n # number of y_i's/observations
  m <<- m # number of replicate data sets
  p <<- p # number of predictors
  
  corr <<- matrix(data=NA, nrow=p, ncol=m)
  varcov <<- varcov.generate(p=p)
  
  y <<- rep(NA, n)
  e <<- rep(NA, n)
  beta1 <<- rep(NA, p)
  beta1hat <<- rep(NA, p)
  beta0 <<- rep(NA, n)
  beta0hat <<- rep(NA, n)
  X <<- matrix(NA, nrow=n, ncol=p)
}

varcov.generate <- function(p, blocks, default_c) {
  if(missing(default_c)) { default_c <- 0.6 }
  if(missing(blocks)) { blocks = c(default_c, p) }
  c <- matrix(data=c(blocks), ncol=2, byrow=T) # correlation of predictors in and size of each block
  if(sum(c[,2]) < p) {
    b_default <-c(default_c, p - sum(c[,2]))
    blocks <- c(blocks, b_default)
    c <- matrix(data=blocks, ncol=2, byrow=T)
  }
  varcov <- matrix(bdiag(apply(c, 1, function(x) {matrix(data=rep(x[1],x[2]**2), nrow=x[2]) + diag(rep(1-x[1], x[2]))})), nrow=p)
}

generate_data <- function() {
#   beta1 <<- rep(0,p)
#   beta0 <<- rep(0,n)
#   e <<- c(data=rnorm(n, mean=0, sd=1))
#   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
#   y <<- e + X %*% beta1 + beta0
  
  e <<- c(data=rnorm(n, mean=0, sd=1)) # needs different variance when response depends on predictors
  #  X<-matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
  #  X<-abs(matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)) 
  # useful for distance measure, since that is just abs of pearson corr coeff when all normal
  X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
  # highly correlated predictors, compound symmetric aka equicorrelated generated by multivariate normal
#   beta0 <<- rep(0,p)
  y <<- e + X %*% beta1 + beta0 # just noise
}

maxes_meds_plots <- function() {
  maxes <<- apply(abs(corr), 2, max)
  plot(density(maxes))
  
  meds <<- apply(abs(corr), 2, median)
  # plot(density(meds))
}

