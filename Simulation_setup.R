################################################################################
# Program: Simulation_setup
# Project: Boucher Senior Thesis
# Description: Conduct a preliminary simulation study for CLS ordering vs SIS
#
# Author: Kimberly Boucher
# Date: 
#
# Notes:

################################################################################

# library(mvtnorm)
library(Matrix)

# Set initial values, define functions for generating data in linear model

initialize_values <- function(n, m, p, t=FALSE, s, seed=20131105) {
  set.seed(seed)
  default_n <- 60
  default_m <- 500
  default_p <- 1000
  default_s <- 1
  
  if(t) {
    default_n <- 6
    default_m <- 50
    default_p <- 100
  }
  
  if(missing(n)) { n <- default_n }
  if(missing(m)) { m <- default_m }
  if(missing(p)) { p <- default_p }
  
  n <<- n # number of y_i's/observations
  m <<- m # number of replicate data sets
  p <<- p # number of predictors
  
  corr.pearson <<- matrix(data=NA, nrow=p, ncol=m)
  corr.dist <<- matrix(data=NA, nrow=p, ncol=m)
  varcov <<- matrix(data=NA, nrow=p, ncol=p)
  
  y <<- rep(NA, n)
  e <<- rep(NA, n)
  beta1 <<- rep(NA, p)
  beta1hat <<- rep(NA, p)
  beta0 <<- rep(NA, n)
  beta0hat <<- rep(NA, n)
  X <<- matrix(NA, nrow=n, ncol=p)
}

generate_cases <- function() {
  cases <<- 1
#   b1 <- matrix(NA, nrow=p, ncol=cases)
#   b0 <- matrix(NA, nrow=n, ncol=cases)
# #   vc <- rep(NA, cases)
#   R.squared <- rep(NA,cases)
# 
#   
#   b1[,1] <- rep(0,p)
#   
#   b0[,1] <- rep(1,n)
#   
# #   vc[[1]] <- varcov.generate(p=p)
#   R.squared[[1]] <- 0.6
#   
#   Cases <<- list(b1, b0, R.squared)
# #   names(cases) <- ("b1", "b0", "vc", "R.squared")
}

get_case <- function(case) {
  beta0 <<- rep(0,n)
  beta1 <<- rep(0,p)
  varcov <<- varcov.generate(p=p)
#   varcov <<- diag(p)
  rs <<- 0.6
}

# generate_data <- function(varcov, rs) {
generate_data <- function() {
# #   beta1 <<- rep(0,p)
# #   beta0 <<- rep(0,n)
# #   e <<- c(data=rnorm(n, mean=0, sd=1))
# #   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
# #   y <<- e + X %*% beta1 + beta0
#   
#   e <<- c(data=rnorm(n, mean=0, sd=1)) # needs different variance when response depends on predictors
#   #  X<-matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
#   #  X<-abs(matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)) 
#   # useful for distance measure, since that is just abs of pearson corr coeff when all normal
#   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
#   # highly correlated predictors, compound symmetric aka equicorrelated generated by multivariate normal
# #   beta0 <<- rep(0,p)
#   y <<- e + X %*% beta1 + beta0 # just noise
  
#   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
  X <<- matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
  
  if(t(beta1) %*% beta1 == 0) {
    e.sd <<- 1
  } else {
    ss <- ((1-rs^2)*t(beta1) %*% varcov %*% beta1)/(rs^2)
    v <- var(X %*% beta1)
    e.sd <<- v/(v + ss)
  }
  e <<- c(data=rnorm(n, mean=0, sd=e.sd))
  
  y <<- e + X %*% beta1 + beta0
  
}

varcov.generate <- function(p, blocks, default_c) {
  if(missing(default_c)) { default_c <- 0.6 }
  if(missing(blocks)) { blocks = c(default_c, p) }
  c <- matrix(data=c(blocks), ncol=2, byrow=T) # correlation of predictors in and size of each block
  if(sum(c[,2]) < p) {
    b_default <-c(default_c, p - sum(c[,2]))
    blocks <- c(blocks, b_default)
    c <- matrix(data=blocks, ncol=2, byrow=T)
  }
  varcov <- matrix(bdiag(apply(c, 1, function(x) {matrix(data=rep(x[1],x[2]**2), nrow=x[2]) + diag(rep(1-x[1], x[2]))})), nrow=p)
}

maxes_meds <- function(maxes_plots=T,meds_plots=T) {
  maxes.dist <<- apply(abs(corr.dist), 2, max)
  maxes.pearson <<- apply(abs(corr.pearson), 2, max)
  meds.dist <<- apply(abs(corr.dist), 2, median)
  meds.pearson <<- apply(abs(corr.pearson), 2, median)
  if(T){ maxes_med_plots()} # TODO: fix the condition
}

maxes_med_plots <- function() {
#   par(mfcol=c(2,2))
#   plot(density(maxes.dist))
#   plot(density(maxes.pearson))
#   plot(density(meds.dist))
#   plot(density(meds.pearson))
  
#   plot(density(maxes.dist), main="Maxes", col="blue", xlim=c(0,1))
#   lines(density(maxes.pearson), col="green")
#   plot(density(meds.dist), main="Medians", col="blue", xlim=c(0,1))
#   lines(density(meds.pearson), col="green")
  
  plot(density(maxes.dist), main="Maximum and Median Correlations", col="blue2", xlim=c(0,1))
  lines(density(maxes.pearson), col="chartreuse4")
  lines(density(meds.dist), col="cornflowerblue")
  lines(density(meds.pearson), col="chartreuse2")
}

# maxes_meds_plots <- function() {
# #   par(mfcol=c(2,2))
#   meds_plots(corr=corr.dist, corr_type="Distance Corr")
# #   par(new=T)
#   meds_plots(corr=corr.pearson, corr_type="Pearson Corr")
# #   maxes_plots(corr=corr.dist, corr_type="Distance Corr")
# #   maxes_plots(corr=corr.pearson, corr_type="Pearson Corr")
# }
# 
# maxes_plots <- function(corr, corr_type) {
#   maxes <<- apply(abs(corr), 2, max)
#   if(!missing(corr_type)) {
#     graph_title = paste("Maxes of ", corr_type)
#     plot(density(maxes), main=graph_title)
#   } else {
#     plot(density(maxes))
#   }
# }
# 
# meds_plots <- function(corr, corr_type) {
#   meds <<- apply(abs(corr), 2, median)
#   if(!missing(corr_type)) {
#     graph_title = paste("Medians of ", corr_type)
#     plot(density(meds), main=graph_title)
#   } else {
#     plot(density(meds))
#   }
# }


