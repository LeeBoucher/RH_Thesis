################################################################################
# Program: Simulation_setup
# Project: Boucher Senior Thesis
# Description: Conduct a preliminary simulation study for CLS ordering vs SIS
#
# Author: Kimberly Boucher
# Date: 
#
# Notes:

################################################################################

# library(mvtnorm)
library(Matrix)

# Set initial values, define functions for generating data in linear model

initialize_values <- function(n, m, p, t=FALSE, s, dcorr_index, seed=20131105) {
  set.seed(seed)
  defaults <- list(n=60, m=500, p=1000, s=1, dcorr_index=1)
#   default_n <- 60
#   default_m <- 500
#   default_p <- 1000
#   default_s <- 1
#   default_dcorr_index <- 1
  
  if(t) {
    defaults <- list(n=6, m=50, p=100, s=defaults$s, dcorr_index=defaults$dcorr_index)
#     default_n <- 6
#     default_m <- 50
#     default_p <- 100
  }
  
  if(missing(n)) { n <- defaults$n }
  if(missing(m)) { m <- defaults$m }
  if(missing(p)) { p <- defaults$p }
  if(missing(dcorr_index)) { dcorr_index <- defaults$dcorr_index }
#   if(missing(n)) { n <- default_n }
#   if(missing(m)) { m <- default_m }
#   if(missing(p)) { p <- default_p }
#   if(missing(dcorr_index)) { dcorr_index <- default_dcorr_index }
  
  n <<- n # number of y_i's/observations
  m <<- m # number of replicate data sets
  p <<- p # number of predictors
  dcorr_index <<- dcorr_index # index for distance correlation
  
  corr.pearson <<- matrix(data=NA, nrow=p, ncol=m)
  corr.dist <<- matrix(data=NA, nrow=p, ncol=m)
  varcov <<- matrix(data=NA, nrow=p, ncol=p)
  
  y <<- rep(NA, n)
  e <<- rep(NA, n)
  beta1 <<- rep(NA, p)
  beta1hat <<- rep(NA, p)
  beta0 <<- rep(NA, n)
  beta0hat <<- rep(NA, n)
  X <<- matrix(NA, nrow=n, ncol=p)
  
  generate_cases()
  
  
}

generate_cases <- function() {
  cases <<- 1
#   b1 <- matrix(NA, nrow=p, ncol=cases)
#   b0 <- matrix(NA, nrow=n, ncol=cases)
# #   vc <- rep(NA, cases)
#   R.squared <- rep(NA,cases)
# 
#   
#   b1[,1] <- rep(0,p)
#   
#   b0[,1] <- rep(1,n)
#   
# #   vc[[1]] <- varcov.generate(p=p)
#   R.squared[[1]] <- 0.6
#   
#   Cases <<- list(b1, b0, R.squared)
# #   names(cases) <- ("b1", "b0", "vc", "R.squared")
}

get_case <- function(case) {
  beta0 <<- rep(0,n)
  beta1 <<- rep(0,p)
  varcov <<- varcov.generate(p=p)
#   varcov <<- diag(p)
  rs <<- 0.6
}

# generate_data <- function(varcov, rs) {
generate_data <- function() {
# #   beta1 <<- rep(0,p)
# #   beta0 <<- rep(0,n)
# #   e <<- c(data=rnorm(n, mean=0, sd=1))
# #   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
# #   y <<- e + X %*% beta1 + beta0
#   
#   e <<- c(data=rnorm(n, mean=0, sd=1)) # needs different variance when response depends on predictors
#   #  X<-matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
#   #  X<-abs(matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)) 
#   # useful for distance measure, since that is just abs of pearson corr coeff when all normal
#   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
#   # highly correlated predictors, compound symmetric aka equicorrelated generated by multivariate normal
# #   beta0 <<- rep(0,p)
#   y <<- e + X %*% beta1 + beta0 # just noise
  
#   X <<- rmvnorm(n, mu=rep(0,p), Sigma=varcov)
  X <<- matrix(data=rnorm(n*p, mean=0, sd=1), nrow=n, ncol=p)
  
  if(t(beta1) %*% beta1 == 0) {
    e.sd <<- 1
  } else {
    ss <- ((1-rs^2)*t(beta1) %*% varcov %*% beta1)/(rs^2)
    v <- var(X %*% beta1)
    e.sd <<- v/(v + ss)
  }
  e <<- c(data=rnorm(n, mean=0, sd=e.sd))
  
  y <<- e + X %*% beta1 + beta0
  
}

varcov.generate <- function(p, blocks, default_c) {
  if(missing(default_c)) { default_c <- 0.6 }
  if(missing(blocks)) { blocks = c(default_c, p) }
  c <- matrix(data=c(blocks), ncol=2, byrow=T) # correlation of predictors in and size of each block
  if(sum(c[,2]) < p) {
    b_default <-c(default_c, p - sum(c[,2]))
    blocks <- c(blocks, b_default)
    c <- matrix(data=blocks, ncol=2, byrow=T)
  }
  varcov <- matrix(bdiag(apply(c, 1, function(x) {matrix(data=rep(x[1],x[2]**2), nrow=x[2]) + diag(rep(1-x[1], x[2]))})), nrow=p)
}

maxes_meds <- function(maxes_plots=T,meds_plots=T) {
  maxes.dist <<- apply(abs(corr.dist), 2, max)
  maxes.pearson <<- apply(abs(corr.pearson), 2, max)
  meds.dist <<- apply(abs(corr.dist), 2, median)
  meds.pearson <<- apply(abs(corr.pearson), 2, median)
#   if(maxes_plots || meds_plots){ 
  # TODO: fix the condition or the maxes_meds_plots function to make 
  # maxes plots and medians plots actually separated options
  maxes_med_plots()
#     }
}

maxes_med_plots <- function() {
#   par(mfcol=c(2,2))
#   plot(density(maxes.dist))
#   plot(density(maxes.pearson))
#   plot(density(meds.dist))
#   plot(density(meds.pearson))
  
#   plot(density(maxes.dist), main="Maxes", col="blue", xlim=c(0,1))
#   lines(density(maxes.pearson), col="green")
#   plot(density(meds.dist), main="Medians", col="blue", xlim=c(0,1))
#   lines(density(meds.pearson), col="green")
  
  graph_title = paste("Maximum and Median Correlations 
    with Pearson Correlation and 
    Distance Correlation (index=", dcorr_index, ")")
  
  plots <- c("Distance Maxes", "Distance Medians", "Pearson Maxes", "Pearson Medians")
  plot_colors <- c("blue2", "cornflowerblue", "chartreuse4", "chartreuse2")
  names(plot_colors) = plots
#   range <- c(0,1)
  range_lower <- min(c(min(meds.pearson), min(meds.dist)))
  range_upper <- max(c(max(maxes.pearson), max(maxes.dist)))
  range_diff <- range_upper - range_lower
  range_padding <- 0.1
  range_extend <- range_padding * range_diff
  range <- c(max(0, range_lower - range_extend), min(1, range_upper + range_extend))
  
  plot(density(maxes.dist), main=graph_title, col=plot_colors["Distance Maxes"], xlim=range)
#   lines(density(maxes.dist), col=plot_colors["Distance Maxes"])
  lines(density(maxes.pearson), col=plot_colors["Pearson Maxes"])
  lines(density(meds.dist), col=plot_colors["Distance Medians"])
  lines(density(meds.pearson), col=plot_colors["Pearson Medians"])
  legend('bottomleft', legend=plots, lty=1, col=plot_colors, bty='n', cex=0.75)
  
#   # TODO: make this whole section not suck
#   maxes_graph_title = paste("Maximum Pearson Correlations and 
#     Distance Correlations (index=", dcorr_index, ")")
#   meds_graph_title = paste("Median Pearson Correlations and 
#     Distance Correlations (index=", dcorr_index, ")")
#   maxes_plots <- c(plots[1], plots[3])
#   meds_plots <- c(plots[2], plots[4])
#   maxes_range_lower <- min(c(min(maxes.pearson), min(maxes.dist)))
#   maxes_range_upper <- max(c(max(maxes.pearson), max(maxes.dist)))
#   maxes_range_diff <- maxes_range_upper - maxes_range_lower
#   maxes_range_extend <- range_padding * maxes_range_diff
#   meds_range_lower <- min(c(min(meds.pearson), min(meds.dist)))
#   meds_range_upper <- max(c(max(meds.pearson), max(meds.dist)))
#   meds_range_diff <- meds_range_upper - meds_range_lower
#   meds_range_extend <- range_padding * meds_range_diff
#   maxes_range <- c(max(0, maxes_range_lower - maxes_range_extend), min(1, maxes_range_upper + maxes_range_extend))
#   meds_range <- c(max(0, meds_range_lower - meds_range_extend), min(1, meds_range_upper + meds_range_extend))
#   
# #   maxes_range <- c(0.5,1)
# #   meds_range <- c(0.2,1)
#   maxes_range <- c(0,1)
#   meds_range <- c(0,1)
#   
#   par(mfrow=c(1,2))
#   plot(density(maxes.dist), main=maxes_graph_title, col=plot_colors["Distance Maxes"], xlim=maxes_range)
#   lines(density(maxes.pearson), col=plot_colors["Pearson Maxes"])
#   legend('bottomleft', legend=maxes_plots, lty=1, col=c(plot_colors[maxes_plots[1]], plot_colors[maxes_plots[2]]),
#          bty='n', cex=0.75) # TODO: these legends are scaling and aligning weird
#   
#   plot(density(meds.dist), main=meds_graph_title, col=plot_colors["Distance Medians"], xlim=meds_range)
#   lines(density(meds.pearson), col=plot_colors["Pearson Medians"])
#   legend('bottomleft', legend=meds_plots, lty=1, col=c(plot_colors[meds_plots[1]], plot_colors[meds_plots[2]]),
#          bty='n', cex=0.75)
}

